<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>shunya</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Arimo:wght@400;500;600;700&display=swap');

        html,
        body {
            height: 100%;
            margin: 0;
            background: #06038D;
            /* Indian chakra navy blue */
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        .text-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 10;
            color: #FFFAF0;
        }

        .text-overlay * {
            pointer-events: auto;
        }

        .header-info {
            position: absolute;
            top: 40px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.5px;
            padding: 0 40px;
        }

        .date {
            opacity: 0.9;
        }

        .location {
            opacity: 0.9;
        }

        .time-container {
            text-align: right;
        }

        .time {
            opacity: 0.9;
        }

        .time-ist {
            opacity: 0.9;
            font-size: 14px;
            margin-top: 2px;
        }

        .company-name {
            position: absolute;
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            font-size: 38.4px;
            font-weight: 300;
            font-family: 'Inter', sans-serif;
            letter-spacing: 2px;
            line-height: 1.1;
            text-transform: uppercase;
        }

        .footer-info {
            position: absolute;
            bottom: 40px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.5px;
            padding: 0 40px;
        }

        .footer-info .location {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .info-link {
            color: #FFFAF0;
            text-decoration: none;
            opacity: 0.9;
            transition: opacity 0.2s ease;
            cursor: pointer;
            pointer-events: auto;
        }

        .info-link:hover {
            opacity: 1;
        }

        .info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(6, 3, 141, 0.95);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .info-modal.active {
            display: block;
        }

        .info-content {
            max-width: 600px;
            padding: 0;
            text-align: left;
            color: #FFFAF0;
            font-family: 'Inter', sans-serif;
            position: absolute;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
        }

        .info-content p {
            font-size: 15px;
            line-height: 1.6;
            margin: 0;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        .close-modal {
            position: absolute;
            bottom: 40px;
            left: 40px;
            color: #FFFAF0;
            text-decoration: none;
            opacity: 0.9;
            transition: opacity 0.2s ease;
            cursor: pointer;
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .close-modal:hover {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .info-content {
                padding: 0;
                max-width: 90%;
                left: 20px;
            }

            .info-content p {
                font-size: 14px;
            }

            .close-modal {
                bottom: 20px;
                left: 20px;
            }
        }

        .email {
            color: #FFFAF0;
            text-decoration: none;
            opacity: 0.9;
            transition: opacity 0.2s ease;
        }

        .email:hover {
            opacity: 1;
        }

        @media (max-width: 768px) {

            .header-info,
            .footer-info {
                padding: 0 20px;
                font-size: 12px;
            }

            .company-name {
                left: 20px;
                font-size: 28.8px;
            }

            .footer-info {
                bottom: 20px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div class="text-overlay">
        <div class="header-info">
            <div class="date">8/21/2025</div>
            <div class="location">SAN FRANCISCO</div>
            <div class="time-container">
                <div class="time">16:57:40 PT</div>
                <div class="time-ist">05:27:40 IST</div>
            </div>
        </div>

        <div class="company-name">
            SHUNYA
        </div>

        <div class="footer-info">
            <div class="info-link" onclick="openInfoModal()">INFO</div>
            <div class="location">BANGALORE</div>
            <div class="email">INFO@SHUNYA.COM</div>
        </div>
    </div>

    <!-- Info Modal -->
    <div class="info-modal" id="infoModal">
        <div class="info-content">
            <p>India doesn't lack technical genius, it lacks the cultural oxygen that lets genius act. Shunya hand picks
                gifted Indian youth and immerses them in Silicon Valley for three months. We believe agency can be
                taught, and greatness can come from anywhere.</p>
        </div>
        <div class="close-modal" onclick="closeInfoModal()">CLOSE</div>
    </div>

    <script>
        // 3D Möbius Strip with OBJ loading
        let scene, camera, renderer, mobiusStrip;
        let mouseX = 0, mouseY = 0;

        // City points and interaction
        let cityPoints = [];
        let sanFranciscoPoint, bangalorePoint;
        let raycaster, mouse3D;
        let connectionLines = [];
        let cityLabels = [];
        // 3D ray-to-point proximity threshold (world units along camera ray)
        let proximityThreshold = 12.0;
        let asciiLines = [];
        let asciiStartMarkers = [];
        let asciiEndMarkers = [];
        let animationFrame = 0;
        let isModalOpen = false;

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x06038D); // Indian chakra navy blue

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            camera.lookAt(0, 0, 0);

            // Create renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-3, -1, -2);
            scene.add(fillLight);

            // Initialize raycaster and mouse vector
            raycaster = new THREE.Raycaster();
            mouse3D = new THREE.Vector2();

            // Load OBJ file
            const loader = new THREE.OBJLoader();
            loader.load(
                'models/mobius_strip.obj',
                function (object) {
                    console.log('Möbius strip loaded successfully!');

                    // Apply material to all meshes in the object
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xFFFAF0, // Warm floral white
                        metalness: 0.1, // Lower metallic property for more natural look
                        roughness: 0.4, // Slightly higher roughness for softer appearance
                        transparent: false,
                        side: THREE.DoubleSide
                    });

                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Scale and position the object (30% bigger + lowered by 40% more)
                    object.scale.set(0.094, 0.094, 0.094);
                    object.position.set(0, -4.5, 0);

                    // Fix initial orientation
                    object.rotation.x = Math.PI * 0.2;
                    object.rotation.y = Math.PI * 0.3;
                    object.rotation.z = 0;

                    scene.add(object);
                    mobiusStrip = object;

                    // Create city points on the Möbius strip
                    createCityPoints();
                },
                function (progress) {
                    console.log('Loading progress: ', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    console.error('Error loading OBJ file:', error);
                    // Fallback: create a simple torus if OBJ loading fails
                    createFallbackTorus();
                }
            );

            // Mouse tracking and window resize handling
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);

            // Start animation
            animate();
        }

        function createFallbackTorus() {
            console.log('Creating fallback torus geometry...');
            const geometry = new THREE.TorusGeometry(1.5, 0.4, 16, 100);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFAF0, // Warm floral white
                metalness: 0.1, // Lower metallic property for more natural look
                roughness: 0.4, // Slightly higher roughness for softer appearance
                side: THREE.DoubleSide
            });

            mobiusStrip = new THREE.Mesh(geometry, material);
            mobiusStrip.scale.set(0.281, 0.281, 0.281);
            mobiusStrip.position.set(0, -4.5, 0);

            // Fix initial orientation for fallback too
            mobiusStrip.rotation.x = Math.PI * 0.2;
            mobiusStrip.rotation.y = Math.PI * 0.3;
            mobiusStrip.rotation.z = 0;

            mobiusStrip.castShadow = true;
            mobiusStrip.receiveShadow = true;
            scene.add(mobiusStrip);

            // Create city points on the fallback torus too
            createCityPoints();
        }

        function createCityPoints() {
            // Create San Francisco point (positioned on one side of the Möbius strip)
            const sanFranciscoGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const sanFranciscoMaterial = new THREE.MeshStandardMaterial({
                color: 0xD4D2C5, // More visible contrast
                metalness: 0.3,
                roughness: 0.2
            });
            sanFranciscoPoint = new THREE.Mesh(sanFranciscoGeometry, sanFranciscoMaterial);

            // Temporary default; will be overridden by farthest-pair calculation
            sanFranciscoPoint.position.set(1.5, 0.8, 0.3);
            // Attach real-world coordinates
            sanFranciscoPoint.userData = { city: 'SAN FRANCISCO', lat: 37.7749, lng: -122.4194 };

            // Add to the Möbius strip so it moves with it
            if (mobiusStrip) {
                mobiusStrip.add(sanFranciscoPoint);
            } else {
                scene.add(sanFranciscoPoint);
            }
            cityPoints.push(sanFranciscoPoint);

            // Create Bangalore point (positioned on opposite side)
            const bangaloreGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const bangaloreMaterial = new THREE.MeshStandardMaterial({
                color: 0xD4D2C5, // More visible contrast
                metalness: 0.3,
                roughness: 0.2
            });
            bangalorePoint = new THREE.Mesh(bangaloreGeometry, bangaloreMaterial);

            // Temporary default; will be overridden by farthest-pair calculation
            bangalorePoint.position.set(-0.4, -1.3, -0.5);
            // Attach real-world coordinates
            bangalorePoint.userData = { city: 'BANGALORE', lat: 12.9716, lng: 77.5946 };

            // Add to the Möbius strip so it moves with it
            if (mobiusStrip) {
                mobiusStrip.add(bangalorePoint);
            } else {
                scene.add(bangalorePoint);
            }
            cityPoints.push(bangalorePoint);

            // After both points exist, reposition them at the two farthest vertices on the strip
            setCityPointsToFarthestPair();
        }

        // Gather all local-space vertex positions from the mobius mesh (including children)
        function collectLocalVerticesFromMesh(rootMesh) {
            const vertices = [];
            if (!rootMesh) return vertices;
            rootMesh.traverse(child => {
                if (child.isMesh && child.geometry && child.geometry.attributes && child.geometry.attributes.position) {
                    const pos = child.geometry.attributes.position;
                    for (let i = 0; i < pos.count; i++) {
                        const v = new THREE.Vector3();
                        v.fromBufferAttribute(pos, i); // local space
                        vertices.push(v);
                    }
                }
            });
            return vertices;
        }

        // Heuristic to find an approximate diameter: farthest-of-farthest
        function findFarthestPair(vertices) {
            if (vertices.length < 2) return null;
            const dist2 = (a, b) => a.distanceToSquared(b);
            let idxA = 0;
            // Find farthest from an arbitrary start
            let maxD = -1, idxB = 0;
            for (let i = 1; i < vertices.length; i++) {
                const d = dist2(vertices[i], vertices[idxA]);
                if (d > maxD) { maxD = d; idxB = i; }
            }
            // From that farthest, find the farthest again
            maxD = -1;
            let idxC = idxB;
            for (let i = 0; i < vertices.length; i++) {
                const d = dist2(vertices[i], vertices[idxB]);
                if (d > maxD) { maxD = d; idxC = i; }
            }
            return [vertices[idxB].clone(), vertices[idxC].clone()];
        }

        function setCityPointsToFarthestPair() {
            if (!mobiusStrip || !sanFranciscoPoint || !bangalorePoint) return;
            const verts = collectLocalVerticesFromMesh(mobiusStrip);
            const pair = findFarthestPair(verts);
            if (!pair) return;
            const [va, vb] = pair;
            // Swap: assign SAN FRANCISCO to vb and BANGALORE to va
            sanFranciscoPoint.position.copy(vb);
            bangalorePoint.position.copy(va);
        }

        function checkCityProximity() {
            if (isModalOpen) return;
            // Update mouse position for raycasting
            mouse3D.x = mouseX;
            mouse3D.y = mouseY;

            // Cast ray from camera through mouse position
            raycaster.setFromCamera(mouse3D, camera);

            // Find the closest city point within threshold (3D ray-to-point distance)
            let closestPoint = null;
            let closestDistance = Infinity;
            let closestIndex = -1;

            cityPoints.forEach((point, index) => {
                const worldPosition = new THREE.Vector3();
                point.getWorldPosition(worldPosition);
                const distance = raycaster.ray.distanceToPoint(worldPosition);
                if (distance < proximityThreshold && distance < closestDistance) {
                    closestPoint = point;
                    closestDistance = distance;
                    closestIndex = index;
                }
            });

            // Hide all connections and labels first
            cityPoints.forEach((point, index) => {
                removeConnectionLine(index);
                hideCityLabel(index);
            });

            // Show connection and label only for the closest point
            if (closestPoint !== null) {
                createConnectionLine(closestPoint);
                showCityLabel(closestPoint);
            }
        }

        function createConnectionLine(cityPoint) {
            const cityIndex = cityPoints.indexOf(cityPoint);

            // Get the world position of the city point
            const cityWorldPosition = new THREE.Vector3();
            cityPoint.getWorldPosition(cityWorldPosition);

            // Convert city point to screen coordinates
            const cityScreenPosition = new THREE.Vector3();
            cityScreenPosition.copy(cityWorldPosition);
            cityScreenPosition.project(camera);

            // Convert to screen pixels (matching Three.js coordinate system)
            const cityX = (cityScreenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const cityY = (-cityScreenPosition.y * 0.5 + 0.5) * window.innerHeight;

            // Get current mouse position in screen pixels (matching the same conversion)
            const mousePixelX = (mouseX * 0.5 + 0.5) * window.innerWidth;
            const mousePixelY = (-mouseY * 0.5 + 0.5) * window.innerHeight;

            // Ensure the city point is visible (not behind camera)
            if (cityScreenPosition.z > 1) return; // Skip if behind camera

            // Create or update ASCII line element
            if (!asciiLines[cityIndex]) {
                const asciiLine = document.createElement('div');
                asciiLine.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    z-index: 1000;
                    color: #FFFAF0;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    font-weight: bold;
                    opacity: 0.9;
                    white-space: nowrap;
                    line-height: 1;
                    transform-origin: 0 50%;
                    top: 0;
                    left: 0;
                    display: block;
                    overflow: hidden;
                `;
                document.body.appendChild(asciiLine);
                asciiLines[cityIndex] = asciiLine;
            }

            const asciiLine = asciiLines[cityIndex];

            // Create or update start marker
            if (!asciiStartMarkers[cityIndex]) {
                const start = document.createElement('div');
                start.textContent = '◉';
                start.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    z-index: 1000;
                    color: #FFFAF0;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    line-height: 1;
                    transform: translate(-50%, -50%);
                `;
                document.body.appendChild(start);
                asciiStartMarkers[cityIndex] = start;
            }

            // Create or update end marker
            if (!asciiEndMarkers[cityIndex]) {
                const end = document.createElement('div');
                end.textContent = '→';
                end.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    z-index: 1000;
                    color: #FFFAF0;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    line-height: 1;
                    transform: translate(-50%, -50%);
                `;
                document.body.appendChild(end);
                asciiEndMarkers[cityIndex] = end;
            }

            // Calculate line direction and length (FROM city TO cursor)
            const dx = mousePixelX - cityX;
            const dy = mousePixelY - cityY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            // Create animated ASCII middle section only; markers handle endpoints
            const asciiChars = ['#', '.', '/', '%', '·', '‧', '•', '∘', '○'];
            const charSpacing = 12; // Pixels per character
            const innerLength = Math.max(1, Math.floor((distance - 20) / charSpacing));
            let asciiContent = '';
            for (let i = 0; i < innerLength; i++) {
                const charIndex = (i + Math.floor(animationFrame / 3)) % asciiChars.length;
                asciiContent += asciiChars[charIndex] + (i < innerLength - 1 ? ' ' : '');
            }

            // Apply content and clip to exact distance
            asciiLine.textContent = asciiContent;
            asciiLine.style.width = `${Math.max(0, distance)}px`;

            // Position and rotate the line so left edge is exactly at city point
            asciiLine.style.transform = `translate(${cityX}px, ${cityY}px) rotate(${angle}rad)`;

            // Position markers at exact endpoints
            const start = asciiStartMarkers[cityIndex];
            const end = asciiEndMarkers[cityIndex];
            start.style.left = `${cityX}px`;
            start.style.top = `${cityY}px`;
            end.style.left = `${mousePixelX}px`;
            end.style.top = `${mousePixelY}px`;
        }

        function removeConnectionLine(cityIndex) {
            if (connectionLines[cityIndex]) {
                scene.remove(connectionLines[cityIndex]);
                connectionLines[cityIndex] = null;
            }
            if (asciiLines[cityIndex]) {
                document.body.removeChild(asciiLines[cityIndex]);
                asciiLines[cityIndex] = null;
            }
            if (asciiStartMarkers[cityIndex]) {
                document.body.removeChild(asciiStartMarkers[cityIndex]);
                asciiStartMarkers[cityIndex] = null;
            }
            if (asciiEndMarkers[cityIndex]) {
                document.body.removeChild(asciiEndMarkers[cityIndex]);
                asciiEndMarkers[cityIndex] = null;
            }
        }

        function showCityLabel(cityPoint) {
            if (isModalOpen) return;
            const cityIndex = cityPoints.indexOf(cityPoint);
            const { city } = cityPoint.userData || {};

            // Create label if needed
            if (!cityLabels[cityIndex]) {
                const label = document.createElement('div');
                label.style.cssText = `
                    position: fixed;
                    color: #FFFAF0;
                    font-family: 'Inter', sans-serif;
                    font-size: 12px;
                    font-weight: 400;
                    letter-spacing: 0.5px;
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 0.15s ease;
                    white-space: nowrap;
                `;
                document.body.appendChild(label);
                cityLabels[cityIndex] = label;
            }

            // Compute cursor screen position
            const mousePixelX = (mouseX * 0.5 + 0.5) * window.innerWidth;
            const mousePixelY = (-mouseY * 0.5 + 0.5) * window.innerHeight;

            // Update text and position slightly offset from the cursor
            const label = cityLabels[cityIndex];
            label.textContent = city || '';
            label.style.left = mousePixelX + 20 + 'px';
            label.style.top = mousePixelY + 10 + 'px';
            label.style.opacity = '1';
        }

        function hideCityLabel(cityIndex) {
            if (cityLabels[cityIndex]) {
                cityLabels[cityIndex].style.opacity = '0';
            }
        }

        function onMouseMove(event) {
            // Convert mouse position to normalized coordinates for raycasting
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check proximity to city points
            checkCityProximity();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Increment animation frame for ASCII line animation
            animationFrame = (animationFrame + 1) % 60;

            // Update any existing ASCII lines for animation
            updateActiveAsciiLines();

            if (mobiusStrip) {
                // Only rotate the strip - NO position changes from cursor
                mobiusStrip.rotation.y += 0.006;

                // Strip stays lowered by 40% more
                mobiusStrip.position.set(0, -4.5, 0);
            }

            renderer.render(scene, camera);
        }

        function updateActiveAsciiLines() {
            if (isModalOpen) return;
            asciiLines.forEach((line, index) => {
                if (line && cityPoints[index]) {
                    // Update the line if it exists and is visible
                    createConnectionLine(cityPoints[index]);
                }
            });
        }

        function clearAllCityUI() {
            cityPoints.forEach((_, index) => {
                removeConnectionLine(index);
                hideCityLabel(index);
            });
        }

        // Initialize when page loads
        window.addEventListener('load', init);

        // Update PT/IST clocks with seconds
        function updateClocks() {
            const now = new Date();
            const pt = now.toLocaleTimeString('en-US', {
                timeZone: 'America/Los_Angeles',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const ist = now.toLocaleTimeString('en-US', {
                timeZone: 'Asia/Kolkata',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const ptEl = document.querySelector('.time');
            const istEl = document.querySelector('.time-ist');
            if (ptEl) ptEl.textContent = `${pt} PT`;
            if (istEl) istEl.textContent = `${ist} IST`;

            const dateEl = document.querySelector('.date');
            if (dateEl) {
                dateEl.textContent = now.toLocaleDateString('en-US');
            }
        }

        // Start the clocks once DOM is ready
        document.addEventListener('DOMContentLoaded', function () {
            updateClocks();
            setInterval(updateClocks, 1000);
        });

        // Add click listener for INFO button
        document.addEventListener('DOMContentLoaded', function () {
            const infoButton = document.querySelector('.info-link');
            console.log('Info button found:', infoButton);

            if (infoButton) {
                infoButton.addEventListener('click', function (e) {
                    console.log('Info button clicked!');
                    e.preventDefault();
                    openInfoModal();
                });
            }
        });

        // Modal functions
        function openInfoModal() {
            console.log('Opening modal...');
            const modal = document.getElementById('infoModal');
            console.log('Modal element:', modal);
            modal.classList.add('active');
            console.log('Modal classes:', modal.classList);
            isModalOpen = true;
            clearAllCityUI();
        }

        function closeInfoModal() {
            console.log('Closing modal...');
            document.getElementById('infoModal').classList.remove('active');
            isModalOpen = false;
        }

        // Close modal when clicking outside content
        document.addEventListener('click', function (event) {
            const modal = document.getElementById('infoModal');
            const content = modal.querySelector('.info-content');
            const closeBtn = modal.querySelector('.close-modal');
            const infoBtn = document.querySelector('.info-link');

            if (modal.classList.contains('active') &&
                !content.contains(event.target) &&
                !closeBtn.contains(event.target) &&
                !infoBtn.contains(event.target)) {
                closeInfoModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                closeInfoModal();
            }
        });
    </script>
</body>

</html>